[{"title":"Javascript-算法-linked list","date":"2017-03-16T13:53:17.000Z","path":"2017/03/16/Javascript-算法-linked-list/","text":"链表：任意添加或移除项，它会按需进行扩容。 要存储多个元素，数组(或列表)可能是最常用的数据结构。这种数据结构非常方便，提供了一个便利的[]语法来访问它的元素。然而，这种数据结构有一个缺点:数组的大小是固定的，从数组的起点或中间插入 或移除项的成本很高，因为需要移动元素。 链表存储有序的元素集合，但不同于数组，链表中的元素在内存中并不是连续放置的。每个元素由一个存储元素本身的节点和一个指向下一个元素的引用组成。 方法 描述 append(element) 向列表尾部添加一个新项。 insert(position, element) 向列表的特定位置插入一个新项。 remove(element) 从列表中移除一项。 removeAt(position) 从列表的特定位置移除一项。 indexOf(element) 返回元素在列表中的索引。如果列表中没有该元素则返回-1。 isEmpty() 如果链表中不包含任何元素，返回true，否则返回false。 size() 返回链表包含的元素个数。 toString() 由于列表项使用了Node类，就需要重写继承自JavaScript对象默认的toString方法，让其只输出元素的值。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798const Node = function(element)&#123; this.element = element; this.next = null;&#125;;function LinkedList() &#123; let length = 0; let head = null; this.append = function(element)&#123; const node = new Node(element); let current; if(length == 0)&#123; head = node; &#125;else&#123; current = head; while(current.next)&#123; current = current.next; &#125; current.next = node; &#125; length ++; &#125;; this.insert = function(position, element)&#123; if(position &gt;=0 &amp;&amp; position &lt;= length)&#123; const node = new Node(element); let current = head, index = 0; if(position == 0)&#123; node.next = head; head = node; &#125;else&#123; while(index != position - 1)&#123; current = current.next; index ++; &#125; node.next = current.next; current.next = node; &#125; length ++; return true; &#125;else&#123; return false; &#125; &#125;; this.removeAt = function(position)&#123; if(position &gt; -1 &amp;&amp; position &lt; length)&#123; let removeEle = head; if(position == 0)&#123; head = head.next; &#125;else&#123; let current = head, index = 0; while(index != position - 1)&#123; current = current.next; index ++; &#125; removeEle = current.next; current.next = current.next.next; &#125; length --; return removeEle.element; &#125;else&#123; return null; &#125; &#125;; this.remove = function(element)&#123;&#125;; this.indexOf = function(element)&#123; let current = head, index = 0; while(current)&#123; if(current.element == element)&#123; return index; &#125;else&#123; current = current.next; index ++; &#125; &#125; return -1; &#125;; this.isEmpty = function() &#123; return (length == 0); &#125;; this.size = function() &#123; return length; &#125;; this.getHead = function() &#123; return head; &#125;; this.toString = function()&#123; let current = head, string = ''; while(current)&#123; string = string + current.element; current = current.next; &#125; return string; &#125;; this.print = function()&#123;&#125;;&#125;const list = new LinkedList();list.append(1);list.append(7);list.append(4);","tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://littlehorsex.com/tags/数据结构与算法/"}]},{"title":"Javascript-算法-array","date":"2017-03-16T12:11:45.000Z","path":"2017/03/16/Javascript-算法-array/","text":"普通数组 方法 描述 array.push() 尾部添加 array.pop() 尾部删除 array.shift() 头部删除 array.unshift() 头部添加 array.splice(5, 0, 1, 2) 索引值为5的地方插入1 2 array.concat 连接2个或更多数组，并返回结果 array.every 对数组中的每一项运行给定函数，如果该函数对每一项都返回true，则返回true aray.some 如果该函数对任意一项返回true，则返回true array.filter 对数组中的每一项运行给定函数，返回该函数会返回true的项组成的数组 array.forEach 对数组中的每一项运行给定函数。这个方法没有返回值 array.map 对数组中的每一项运行给定函数，返回每次函数调用的结果组成的数组 数组模拟栈（后进先出） 方法 描述 push(element(s)) 添加一个(或几个)新元素到栈顶。 pop() 移除栈顶的元素，同时返回被移除的元素。 peek() 返回栈顶的元素，不对栈做任何修改(这个方法不会移除栈顶的元素，仅仅返回它)。 isEmpty() 如果栈里没有任何元素就返回true，否则返回false。 clear() 移除栈里的所有元素。 size() 返回栈里的元素个数。这个方法和数组的length属性很类似。 数组模拟队列（先进先出） 方法 描述 enqueue(element(s)) 向队列尾部添加一个(或多个)新的项。 dequeue() 移除队列的第一项，并返回被移除的元素。 front() 返回队列中第一个元素——最先被添加，也将是最先被移除的元素。队列不做任何变动(不移除元素，只返回元素信息)。 isEmpty() 如果队列中不包含任何元素，返回true，否则返回false。 size() 返回队列包含的元素个数，与数组的length属性类似。 循环队列——击鼓传花1234567891011121314151617181920function hotPotato(nameList, num)&#123; var queue = new Queue(); for (var i=0; i&lt;nameList.length; i++)&#123; queue.enqueue(nameList[i]); // 得到一份名单，把里面的名字全都加入队列 &#125; var eliminated = ''; while (queue.size() &gt; 1)&#123; for (var i=0; i&lt;num; i++)&#123; queue.enqueue(queue.dequeue()); // 给定一个数字，然后迭代队列。从队列开头移除一项，再将其添加到队列末尾 &#125; eliminated = queue.dequeue(); // 一旦传递次数达到给定的数字，拿着花的那个人就被淘汰了 console.log(eliminated + '在击鼓传花游戏中被淘汰。'); &#125; return queue.dequeue(); &#125; var names = ['John','Jack','Camila','Ingrid','Carl']; var winner = hotPotato(names, 7); console.log('胜利者:' + winner);","tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://littlehorsex.com/tags/数据结构与算法/"}]},{"title":"JavaScript 运行机制---q","date":"2017-03-04T06:05:27.000Z","path":"2017/03/04/JavaScript-运行机制-q/","text":"123for (var i = 0; i &lt; 5; i++) &#123; console.log(i);&#125; // 0 1 2 3 4 12345for (var i = 0; i &lt; 5; i++) &#123; setTimeout(function() &#123; console.log(i); &#125;, 1000 * i);&#125; // 5 5 5 5 5 开始输出一个 5，然后每隔一秒再输出一个 5，一共 5 个 5 1234567for (var i = 0; i &lt; 5; i++) &#123; (function(i) &#123; setTimeout(function() &#123; console.log(i); &#125;, i * 1000); &#125;)(i);&#125; // 0 1 2 3 4 闭包，内部对 i 保持引用 1234567for (var i = 0; i &lt; 5; i++) &#123; (function() &#123; setTimeout(function() &#123; console.log(i); &#125;, i * 1000); &#125;)(i);&#125; // 5 5 5 5 5 内部没有对i引用 12345for (var i = 0; i &lt; 5; i++) &#123; setTimeout((function(i) &#123; console.log(i); &#125;)(i), i * 1000);&#125; // 0 1 2 3 4 立即执行函数 12345678910111213setTimeout(function() &#123; console.log(1)&#125;, 0);new Promise(function executor(resolve) &#123; console.log(2); for( var i=0 ; i&lt;10000 ; i++ ) &#123; i == 9999 &amp;&amp; resolve(); &#125; console.log(3);&#125;).then(function() &#123; console.log(4);&#125;);console.log(5); 这道题应该考察 JavaScript 的运行机制的，让我理一下思路。首先先碰到一个 setTimeout，于是会先设置一个定时，在定时结束后将传递这个函数放到任务队列里面，因此开始肯定不会输出 1 。然后是一个 Promise，里面的函数是直接执行的，因此应该直接输出 2 3 。然后，Promise 的 then 应当会放到当前 tick 的最后，但是还是在当前 tick 中。因此，应当先输出 5，然后再输出 4 。最后在到下一个 tick，就是 1 。“2 3 5 4 1”","tags":[{"name":"习得","slug":"习得","permalink":"http://littlehorsex.com/tags/习得/"}]},{"title":"JavaScript 运行机制---a","date":"2017-03-04T06:05:19.000Z","path":"2017/03/04/JavaScript-运行机制-a/","text":"工作做完的闲暇之余逛了segmentfault，发现了一篇有意思的文章——JavaScript 运行机制—q，发现自己对javascript的闭包以及运行机制并不了解，特查资料，整理。 123456789function f1()&#123; var n=999; // n为f1函数的内部变量，外部无法访问 function f2()&#123; // f2为f1的内部函数，可以访问f1的内部变量，只要返回f2，外部也可以访问f1的内部变量了 alert(n); &#125; return f2;&#125;var result=f1();result(); // 999 F2函数就是闭包，闭包就是能够读取其他函数内部变量的函数，是把函数内部和外部连接的桥梁。 闭包的作用有两个：一是可以读取函数内部的变量，二是让这些变量的值始终存在内存中。 123456789101112function f1()&#123; var n=999; nAdd=function()&#123;n+=1&#125; function f2()&#123; alert(n); &#125; return f2;&#125;var result=f1();result(); // 999nAdd();result(); // 1000 这段代码中，rusult实际上就是闭包函数f2，他一共运行了两次，第一次为999，第二次为1000，这证明了函数f1的局部变量n一直保存在内存中，并没有在f1调用之后被自动清除。原因是，f1是f2的父函数，而f2赋值给了一个全局变量，导致f2始终在内存中，而f2始终依赖于f1，因此f1也始终在内存中，不会在调用后被垃圾回收机制回收。 闭包的大概内容就到此为止，下面，我们来学习一下js的运行机制。 js的一大特点就是单线程，也就是同一时间只能做一件事。单线程就意味着所有任务需要排队，前一个任务结束才会进行下一个任务。当任务需要IO设备时，（比如等着ajax操作获取数据）虽然CPU是空闲状态，但不得不等着结果返回才能进行下一个任务。这时，主线程完全可以不管IO设备，挂起等待中的任务，先运行排在后面的任务，等IO设备返回了结果，再把挂起的任务继续执行。 因此，所有任务可以分为两种，一种同步任务，一种异步任务。同步任务指的是，在主线程上排队执行的任务，只有前一个任务执行结束，才能执行后一个任务。异步任务指的是，不进入主线程，而进入“任务队列”的任务，只有“任务队列”通知主线程，该任务可以执行，才进入主线程。 所有同步任务都在主线程上执行，形成一个执行栈（execution context stack）。 主线程之外，还存在一个”任务队列”（task queue）。只要异步任务有了运行结果，就在”任务队列”之中放置一个事件。 一旦”执行栈”中的所有同步任务执行完毕，系统就会读取”任务队列”，看看里面有哪些事件。那些对应的异步任务，于是结束等待状态，进入执行栈，开始执行。 主线程不断重复上面的第三步。 “任务队列”中的事件，除了IO设备的事件以外，还包括一些用户产生的事件（比如鼠标点击、页面滚动等等）。只要指定过回调函数，这些事件发生时就会进入”任务队列”，等待主线程读取。 所谓”回调函数”（callback），就是那些会被主线程挂起来的代码。异步任务必须指定回调函数，当主线程开始执行异步任务，就是执行对应的回调函数。 主线程从”任务队列”中读取事件，这个过程是循环不断的，所以整个的这种运行机制又称为Event Loop（事件循环）。 除了放置异步任务的事件，”任务队列”还可以放置定时事件，即指定某些代码在多少时间之后执行。","tags":[{"name":"习得","slug":"习得","permalink":"http://littlehorsex.com/tags/习得/"}]},{"title":"TwoDogZi之旅","date":"2017-03-03T06:50:00.000Z","path":"2017/03/03/TwoDogZi之旅/","text":"吃 已完成铁板自助潮汕牛肉火锅 待吃海鲜自助虾吃虾涮日本料理","tags":[{"name":"随笔","slug":"随笔","permalink":"http://littlehorsex.com/tags/随笔/"}]},{"title":"Hello World","date":"2017-03-03T05:57:37.000Z","path":"2017/03/03/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy 1$ hexo clean &amp;&amp; hexo g &amp;&amp; hexo d More info: Deployment","tags":[{"name":"init","slug":"init","permalink":"http://littlehorsex.com/tags/init/"}]}]