[{"title":"JavaScript 运行机制---q","date":"2017-03-04T06:05:27.000Z","path":"2017/03/04/JavaScript-运行机制-q/","text":"123for (var i = 0; i &lt; 5; i++) &#123; console.log(i);&#125; // 0 1 2 3 4 12345for (var i = 0; i &lt; 5; i++) &#123; setTimeout(function() &#123; console.log(i); &#125;, 1000 * i);&#125; // 5 5 5 5 5 开始输出一个 5，然后每隔一秒再输出一个 5，一共 5 个 5 1234567for (var i = 0; i &lt; 5; i++) &#123; (function(i) &#123; setTimeout(function() &#123; console.log(i); &#125;, i * 1000); &#125;)(i);&#125; // 0 1 2 3 4 闭包，内部对 i 保持引用 1234567for (var i = 0; i &lt; 5; i++) &#123; (function() &#123; setTimeout(function() &#123; console.log(i); &#125;, i * 1000); &#125;)(i);&#125; // 5 5 5 5 5 内部没有对i引用 12345for (var i = 0; i &lt; 5; i++) &#123; setTimeout((function(i) &#123; console.log(i); &#125;)(i), i * 1000);&#125; // 0 1 2 3 4 立即执行函数 12345678910111213setTimeout(function() &#123; console.log(1)&#125;, 0);new Promise(function executor(resolve) &#123; console.log(2); for( var i=0 ; i&lt;10000 ; i++ ) &#123; i == 9999 &amp;&amp; resolve(); &#125; console.log(3);&#125;).then(function() &#123; console.log(4);&#125;);console.log(5); 这道题应该考察 JavaScript 的运行机制的，让我理一下思路。 首先先碰到一个 setTimeout，于是会先设置一个定时，在定时结束后将传递这个函数放到任务队列里面，因此开始肯定不会输出 1 。 然后是一个 Promise，里面的函数是直接执行的，因此应该直接输出 2 3 。 然后，Promise 的 then 应当会放到当前 tick 的最后，但是还是在当前 tick 中。 因此，应当先输出 5，然后再输出 4 。 最后在到下一个 tick，就是 1 。 “2 3 5 4 1”","tags":[{"name":"习得","slug":"习得","permalink":"http://littlehorsex.com/tags/习得/"}]},{"title":"JavaScript 运行机制---a","date":"2017-03-04T06:05:19.000Z","path":"2017/03/04/JavaScript-运行机制-a/","text":"工作做完的闲暇之余逛了segmentfault，发现了一篇有意思的文章——JavaScript 运行机制—q，发现自己对javascript的闭包以及运行机制并不了解，特查资料，整理。 123456789function f1()&#123; var n=999; // n为f1函数的内部变量，外部无法访问 function f2()&#123; // f2为f1的内部函数，可以访问f1的内部变量，只要返回f2，外部也可以访问f1的内部变量了 alert(n); &#125; return f2;&#125;var result=f1();result(); // 999 F2函数就是闭包，闭包就是能够读取其他函数内部变量的函数，是把函数内部和外部连接的桥梁。 闭包的作用有两个：一是可以读取函数内部的变量，二是让这些变量的值始终存在内存中。 123456789101112function f1()&#123; var n=999; nAdd=function()&#123;n+=1&#125; function f2()&#123; alert(n); &#125; return f2;&#125;var result=f1();result(); // 999nAdd();result(); // 1000 这段代码中，rusult实际上就是闭包函数f2，他一共运行了两次，第一次为999，第二次为1000，这证明了函数f1的局部变量n一直保存在内存中，并没有在f1调用之后被自动清除。原因是，f1是f2的父函数，而f2赋值给了一个全局变量，导致f2始终在内存中，而f2始终依赖于f1，因此f1也始终在内存中，不会在调用后被垃圾回收机制回收。 闭包的大概内容就到此为止，下面，我们来学习一下js的运行机制。 js的一大特点就是单线程，也就是同一时间只能做一件事。单线程就意味着所有任务需要排队，前一个任务结束才会进行下一个任务。当任务需要IO设备时，（比如等着ajax操作获取数据）虽然CPU是空闲状态，但不得不等着结果返回才能进行下一个任务。这时，主线程完全可以不管IO设备，挂起等待中的任务，先运行排在后面的任务，等IO设备返回了结果，再把挂起的任务继续执行。 因此，所有任务可以分为两种，一种同步任务，一种异步任务。同步任务指的是，在主线程上排队执行的任务，只有前一个任务执行结束，才能执行后一个任务。异步任务指的是，不进入主线程，而进入“任务队列”的任务，只有“任务队列”通知主线程，该任务可以执行，才进入主线程。 所有同步任务都在主线程上执行，形成一个执行栈（execution context stack）。 主线程之外，还存在一个”任务队列”（task queue）。只要异步任务有了运行结果，就在”任务队列”之中放置一个事件。 一旦”执行栈”中的所有同步任务执行完毕，系统就会读取”任务队列”，看看里面有哪些事件。那些对应的异步任务，于是结束等待状态，进入执行栈，开始执行。 主线程不断重复上面的第三步。 “任务队列”中的事件，除了IO设备的事件以外，还包括一些用户产生的事件（比如鼠标点击、页面滚动等等）。只要指定过回调函数，这些事件发生时就会进入”任务队列”，等待主线程读取。 所谓”回调函数”（callback），就是那些会被主线程挂起来的代码。异步任务必须指定回调函数，当主线程开始执行异步任务，就是执行对应的回调函数。 主线程从”任务队列”中读取事件，这个过程是循环不断的，所以整个的这种运行机制又称为Event Loop（事件循环）。 除了放置异步任务的事件，”任务队列”还可以放置定时事件，即指定某些代码在多少时间之后执行。","tags":[{"name":"习得","slug":"习得","permalink":"http://littlehorsex.com/tags/习得/"}]},{"title":"二狗","date":"2017-03-03T06:50:00.000Z","path":"2017/03/03/二狗/","text":"","tags":[{"name":"随笔","slug":"随笔","permalink":"http://littlehorsex.com/tags/随笔/"}]},{"title":"Hello World","date":"2017-03-03T05:57:37.000Z","path":"2017/03/03/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy 1$ hexo clean &amp;&amp; hexo g &amp;&amp; hexo d More info: Deployment","tags":[]}]