[{"title":"Javascript-正则表达式","date":"2017-03-29T04:27:56.000Z","path":"2017/03/29/Javascript-正则表达式/","text":"javascript中的正则表达式用RegExp类型表示，有两种写法：一种是字面量写法；另一种是构造函数写法 正则表达式字面量写法，又叫Perl写法 var expression = /pattern/flags; 正则表达式的匹配模式支持下列3个标志： g:表示全局(global)模式，即模式将被应用于所有字符串，而非在发现第一个匹配项时立即停止i:表示不区分大小写(case-insensitive)模式，即在确定匹配项时忽略模式与字符串的大小写m:表示多行(multiline)模式，即在到达一行文本末尾时还会继续查找下一行中是否存在与模式匹配的项 RegExp构造函数 var re = new RegExp(‘at’,’g’); 由于 RegExp 构造 函数的模式参数是字符串，所以在某些情况下要对字符进行双重转义。所有元字符都必须双重转义，那 些已经转义过的字符也是如此，例如\\n(字符\\在字符串中通常被转义为\\，而在正则表达式字符串中就 会变成\\\\)。 元字符在javascript中，共有14个元字符(meta-character) () [] {} \\ ^ $ | ? * + . 元字符 名称 匹配对象 . 点号 单个任意字符(除回车\\r、换行\\n、行分隔符\\u2028和段分隔符\\u2029外) [] 字符组 列出的单个任意字符 [^] 排除型字符组 未列出的单个任意字符 ? 问号 匹配0次或1次 * 星号 匹配0交或多次 + 加号 匹配1次或多次 {min,max} 区间量词 匹配至少min次，最多max次 ^ 脱字符 行的起始位置 $ 美元符 行的结束位置 &#124; 竖线 分隔两边的任意一个表达式 () 括号 限制多选结构的范围，标注量词作用的元素，为反向引用捕获文本 \\1,\\2… 反向引用 匹配之前的第一、第二…组括号内的表达式匹配的文本 RegExp实例属性 global:布尔值，表示是否设置了 g 标志。ignoreCase:布尔值，表示是否设置了 i 标志。lastIndex:整数，表示开始搜索下一个匹配项的字符位置，从 0 算起。multiline:布尔值，表示是否设置了 m 标志。source:正则表达式的字符串表示，按照字面量形式而非传入构造函数中的字符串模式返回 RegExp实例方法RegExp 对象的主要方法是 exec()，该方法是专门为捕获组而设计的。exec()接受一个参数，即 要应用模式的字符串，然后返回包含第一个匹配项信息的数组;或者在没有匹配项的情况下返回 null。 返回的数组虽然是 Array 的实例，但包含两个额外的属性:index 和 input。其中，index 表示匹配 项在字符串中的位置，而 input 表示应用正则表达式的字符串。 12345678var text = \"mom and dad and baby\";var pattern = /mom( and dad( and baby)?)?/gi;var matches = pattern.exec(text);alert(matches.index); //0alert(matches.input); // \"mom and dad and baby\" alert(matches[0]); // \"mom and dad and baby\" alert(matches[1]); // \" and dad and baby\"alert(matches[2]); // \" and baby\" 正则表达式的第二个方法是 test()，它接受一个字符串参数。在模式与该参数匹配的情况下返回 true;否则，返回 false。 指定匹配的位置 ^ 匹配一个输入或一行的开头，/^a/匹配”an A”，而不匹配”An a”$ 匹配一个输入或一行的结尾，/a$/匹配”An a”，而不匹配”an A”x|y 匹配x或y\\b 匹配一个单词的边界\\B 匹配一个单词的非边界 量词 * 匹配前面元字符0次或多次，/ba/将匹配b,ba,baa,baaa+ 匹配前面元字符1次或多次，/ba/将匹配ba,baa,baaa? 匹配前面元字符0次或1次，/ba*/将匹配b,ba{n} 精确匹配n次{n,} 匹配n次以上{n,m} 匹配n-m次 预定义特殊字符 \\n 匹配一个换行符\\r 匹配一个回车符\\t 匹配一个制表符\\v 匹配一个重直制表符\\t 制表符\\cX 这儿，X是一个控制符，/\\cM/匹配Ctrl-M[\\b] 匹配一个退格符 预定义类 \\d 匹配一个字数字符，/\\d/ = /[0-9]/\\D 匹配一个非字数字符，/\\D/ = /[^0-9]/\\s 匹配一个空白字符，包括\\n,\\r,\\f,\\t,\\v等\\S 匹配一个非空白字符，等于/[^\\n\\f\\r\\t\\v]/\\w 匹配一个可以组成单词的字符(alphanumeric，这是我的意译，含数字)，包括下划线，如[\\w]匹配”$5.98”中的5，等于[a-zA-Z0-9]\\W 匹配一个不可以组成单词的字符，如[\\W]匹配”$5.98”中的$，等于[^a-zA-Z0-9]。[…] 字符集(character set)，匹配这个集合中的任一一个字符(或元字符)[^…] 不匹配这个集合中的任何一个字符 任意字符 . IE下[^\\n]，其它[^\\n\\r] 匹配除换行符之外的任何一个字符 贪婪量词与惰性量词 用贪婪量词进行匹配时，它首先会将整会字符串当成一个匹配，如果匹配的话就退出，如果不匹配，就截去最后一个字符进行匹配，如果不匹配，继续将最后一个字符截去进行匹配，直到有匹配为止。直到现在我们遇到的量词都是贪婪量词用惰性量词进行匹配时，它首先将第一个字符当成一个匹配，如果成功则退出，如果失败，则测试前两个字符，依些增加，直到遇到合适的匹配为止惰性量词仅仅在贪婪量词后面加个”?”而已,如”a+”是贪婪匹配的,”a+?”则是惰性的 括号 括号有两个功能，分别是分组和引用。分组:如果把一个表达式用括号包围起来，这个元素就是括号里的表达式，被称为子表达式,如果希望字符串’ab’重复出现2次，应该写为(ab){2}，而如果写为ab{2}，则{2}只限定b捕获: console.log(/(\\d{4})-(\\d{2})-(\\d{2})/.test(‘2016-06-23’));//true console.log(RegExp.$1);//‘2016’ console.log(RegExp.$2);//‘06’ 反向引用 英文中不少单词都有重叠出现的字母，如shoot或beep。若想检查某个单词是否包含重叠出现的字母，则需要引入反向引用(back-reference)反向引用允许在正则表达式内部引用之前捕获分组匹配的文本，形式是\\num，num表示所引用分组的编号console.log(/([a-z])\\1/.test(‘aa’));//true 单词边界 在文本处理中经常可能进行单词替换，比如把row替换成line。但是，如果直接替换，不仅所有单词row都被替换成line，单词内部的row也会被替换成line。要想解决这个问题，必须有办法确定单词row，而不是字符串row为了解决这类问题，正则表达式提供了专用的单词边界(word boundary)，记为\\b，它匹配的是’单词边界’位置，而不是字符。\\b匹配的是一边是单词字符\\w，一边是非单词字符\\W的位置console.log(/\\ban\\b/.test(‘an’));//trueconsole.log(/\\ban\\b/.test(‘and’));//false 优先级 //从上到下，优先级逐渐降低\\ 转义符() (?!) (?=) [] 括号、字符组、环视* + ? {n} {n,} {n,m} 量词^ $ 起始结束位置| 选择","tags":[]},{"title":"websocket初探","date":"2017-03-27T11:21:27.000Z","path":"2017/03/27/websocket初探/","text":"websocket诞生背景当我们的客户端需要和服务器交互数据时，我们通常用轮询来请求数据，客户端以一定的时间间隔向服务端发出请求，以频繁请求的方式来保持客户端和服务器端的同步。这样频繁的请求中，服务端数据很可能没有更新，从而会带来很多无谓的网络传输，所以这是一种非常低效的实时方案。而通过websocket，浏览器通过JavaScript向服务器发出建立WebSocket连接的请求，连接建立以后，客户端和服务器端就可以通过TCP连接直接交换数据，当服务器数据更新后，向客户端推送数据，避免了不必要的网络传输浪费。 12345678910111213var ws = new WebSocket(url);ws.onclose = function () &#123; //...&#125;;ws.onerror = function () &#123; //...&#125;; ws.onopen = function () &#123; //...&#125;;ws.onmessage = function (event) &#123; //...&#125; 如果希望websocket连接一直保持，我们会在close或者error上绑定重新连接方法。这样一般正常情况下失去连接时，触发onclose方法，我们就能执行重连了。 心跳重连缘由在使用websocket过程中，可能会出现网络断开的情况，比如信号不好，或者网络临时性关闭，这时候websocket的连接已经断开， 而浏览器不会执行websocket 的 onclose方法，我们无法知道是否断开连接，也就无法进行重连操作。 如果当前发送websocket数据到后端，一旦请求超时，onclose便会执行，这时候便可进行绑定好的重连操作。 因此websocket心跳重连就应运而生。 心跳重连简单实现1234567891011121314151617181920var heartCheck = &#123; timeout: 60000,//60ms timeoutObj: null, reset: function()&#123; clearTimeout(this.timeoutObj); this.start(); &#125;, start: function()&#123; this.timeoutObj = setTimeout(function()&#123; ws.send(\"HeartBeat\", \"beat\"); &#125;, this.timeout) &#125;&#125;ws.onopen = function () &#123; heartCheck.start();&#125;;ws.onmessage = function (event) &#123; heartCheck.reset();&#125; 当onopen也就是连接上时，我们便开始start计时，如果在定时时间范围内，onmessage获取到了服务器的消息，我们就重置倒计时， 所以在距离上次从服务器获取到消息，闲置60秒之后我们才会心跳检测，这个检测时间可以自己根据自身情况设定。 当心跳检测send执行之后，如果当前websocket是断开状态，发送超时之后，onclose方法便会被执行，重连也执行了。 如此一来，我们判断前端主动断开ws的心跳检测就实现了。为什么说是前端主动断开，因为当前这种情况主要是通过前端ws的事件来判断的，后面说后端主动断开的情况。 解决多端浏览器访问问题多端浏览器发送的ws链接不同，以此区分，但一个浏览器的多个tab页面，ws链接一样，这样会出现一个服务器对应多个客户端的情况，下面介绍解决方案。 解决多端浏览器访问问题多个tab之间使用领导者思想，始终只保留一个leader作为主页面，即websocket链接的发起者，具体实现思路如下： 1.每个页面加载时，都保存当前时间作为当前页面的页面ID2.设置一个1s的定时器，定时检测localstorage3.若发现localstorage中不存在leaderID，则表示当前页面不存在leader，则把自己的ID，以及当前时间分别存在localstorage的leaderID和leaderTime中4.页面设置leader后，定时器定时检查当前leaderID是否与自己的id一致，如果一致，则修改leaderTime为当前时间，表示leader页面尚未关闭5.若leaderTime与当前时间间隔超过3s，则表示leader页面已死亡，需要有一个新leader诞生6.谁最先发现了前任leader已死，谁就自然成为新任leader，将自己的ID存为leaderID，且更新当前时间为leaderTime，表示当前时间存在leader 12345678910111213141516const id = Date.now();setInterval(() =&gt; &#123; if (!localStorage.leaderTime) &#123; localStorage.setItem('leaderId', id); localStorage.setItem('leaderTime', Date.now()); &#125; else if (Date.now() - localStorage.leaderTime &gt; 3000) &#123; console.log('dead'); localStorage.setItem('leaderId', id); localStorage.setItem('leaderTime', Date.now()); isLeader(); &#125; else if (parseInt(localStorage.leaderId) === id) &#123; console.log('I am leader’); localStorage.setItem('leaderTime', Date.now()); &#125;&#125;, 1000); 数据显示ws建立成功后，接下来就是显示数据的部分，由于情况较多，采用图表展示： 数字： leader 新页面 接收数据时 dispatch(setCount()), 使用定时器this.props.dispatch(fetchCount())显示数据 子页面 新页面 接收数据时 localStorage.setItem(‘warningCount’, ${obj.req_args.apns.aps.alert}-${Date.now()}); 使用window.addEventListener(‘storage’, e =&gt; { 触发dispatch显示数据 之所以加上时间戳是因为当localStorage连续保存相同数据时，页面不再触发storage事件 leader 旧页面 接收数据时 window.warningCount = obj.req_args.apns.aps.alert; 在旧页面使用this.setState({num: window.warningCount})显示数据 子页面 旧页面 同新页面的子页面，但要在旧页面代码中写storage函数，因为要使用setstate显示数据 文字： leader 新页面 接收数据时 notification.warning({ 并显示数据 子页面 新页面 接收数据时 localStorage.setItem(‘warningMessage’, ${obj.req_args.apns.aps.alert}-${Date.now()}); 使用window.addEventListener(‘storage’, e =&gt; { 触发notification显示数据 leader 旧页面 同 leader 新页面 子页面 旧页面 同 子页面 新页面 注：保存localStorage的主页面不会触发storage事件 代码示例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899import &#123; notification &#125; from 'antd';import callApi from 'scripts/utils/resolve-data-source';import configureStores from 'scripts/stores/configureStores';import &#123; setCount &#125; from 'scripts/actions/prewarning';const dispatch = configureStores.dispatch;function isLeader() &#123; callApi(&#123; url: '/scmmain/bind', method: 'GET', &#125;).then((buildWs) =&gt; &#123; if (buildWs) &#123; const url = `ws://10.19.160.118:8344/websocket?appid=1006&amp;cuid=$&#123;buildWs&#125;&amp;os=browser`; let ws; const heartCheck = &#123; timeoutObj: null, start: () =&gt; &#123; heartCheck.timeoutObj = setTimeout(() =&gt; &#123; ws.send(JSON.stringify(&#123; appid: '1006', req_id: '10', req_type: '5', ver: '1.0', &#125;)); &#125;, 10000); &#125;, reset: () =&gt; &#123; clearTimeout(heartCheck.timeoutObj); heartCheck.start(); &#125;, &#125;; const eventHandlers = &#123; onopen: () =&gt; &#123; heartCheck.start(); &#125;, onmessage: function handle(e) &#123; heartCheck.reset(); const obj = JSON.parse(e.data); console.log('alert = ', obj.req_args.apns.aps.alert); if (obj.req_args.apns.aps.title === '库存不足报警') &#123; window.warningCount = obj.req_args.apns.aps.alert; localStorage.setItem('warningCount', `$&#123;obj.req_args.apns.aps.alert&#125;-$&#123;Date.now()&#125;`); dispatch(setCount(obj.req_args.apns.aps.alert)); &#125; else &#123; localStorage.setItem('warningMessage', `$&#123;obj.req_args.apns.aps.alert&#125;-$&#123;Date.now()&#125;`); notification.warning(&#123; message: obj.req_args.apns.aps.alert, duration: 10, &#125;); &#125; &#125;, onclose: () =&gt; &#123; console.log('closing...'); ws = new WebSocket(url); Object.assign(ws, eventHandlers); &#125;, &#125;; ws = new WebSocket(url); Object.assign(ws, eventHandlers); &#125; else &#123; localStorage.setItem('warningMessage', '绑定设备失败，无法接收推送消息'); notification.warning(&#123; message: '绑定设备失败，无法接收推送消息', duration: 10, &#125;); &#125; &#125;);&#125;const id = Date.now();setInterval(() =&gt; &#123; if (!localStorage.leaderTime) &#123; localStorage.setItem('leaderId', id); localStorage.setItem('leaderTime', Date.now()); isLeader(); &#125; else if (Date.now() - localStorage.leaderTime &gt; 3000) &#123; console.log('dead'); localStorage.setItem('leaderId', id); localStorage.setItem('leaderTime', Date.now()); isLeader(); &#125; else if (parseInt(localStorage.leaderId, 10) === id) &#123; console.log('I am leader'); localStorage.setItem('leaderTime', Date.now()); &#125;&#125;, 1000);window.addEventListener('storage', e =&gt; &#123; if (e.key === 'warningMessage') &#123; console.log('warningMessage = ', e.newValue); notification.warning(&#123; message: e.newValue.split('-')[0], duration: 10, &#125;); &#125; else if (e.key === 'warningCount') &#123; console.log('warningCount = ', e.newValue); dispatch(setCount(e.newValue.split('-')[0])); &#125;&#125;);","tags":[{"name":"websocket","slug":"websocket","permalink":"http://littlehorsex.com/tags/websocket/"}]},{"title":"RXJS----Scheduler调度者","date":"2017-03-24T13:45:47.000Z","path":"2017/03/24/RXJS-Scheduler调度者/","text":"什么是调度者？调度者控制着何时启动一个订阅和何时通知被发送。它有三个组件构成: 一个调度者是一个数据结构。它知道如何根据优先级或其他标准存储和排列任务。 一个调度者是一个执行上下文。它表示何处何时任务被执行(例如: immediately(立即), or in another callback mechanism(回调机制) such as setTimeout or process.nextTick, or the animation frame) 一个调度者具有虚拟的时钟。它通过调度器上的getter方法now()提供了“时间”的概念。 在特定调度程序上调度的任务将仅仅遵守由该时钟表示的时间。 调度者使得你可以确定可观察对象在什么执行上下文中给观察者发送通知 下面的例子，我们使用常见的的可观察对象，它同步的发送三个数值1/2/3。使用observeOn操作符指定用于传递这些值的异步调度程序。 123456789101112131415var observable = Rx.Observable.create(function (observer) &#123; observer.next(1); observer.next(2); observer.next(3); observer.complete();&#125;).observeOn(Rx.Scheduler.async);console.log('just before subscribe');observable.subscribe(&#123; next: x =&gt; console.log('got value ' + x), error: err =&gt; console.error('something wrong occurred: ' + err), complete: () =&gt; console.log('done'),&#125;);console.log('just after subscribe'); 输出 123456just before subscribejust after subscribegot value 1got value 2got value 3done 注意如何获取值…被发送在”just after subscribe “之后，这是不同于我们目前为止所看到的默认行为。 这是因为observeOn（Rx.Scheduler.async）在Observable.create和最终的Observer之间引入了一个代理Observer。 让我们重命名一些标识符，使这个重要的区别在下面代码中显而易见： 1234567891011121314151617181920212223242526272829var observable = Rx.Observable.create(function (proxyObserver) &#123; proxyObserver.next(1); proxyObserver.next(2); proxyObserver.next(3); proxyObserver.complete();&#125;).observeOn(Rx.Scheduler.async);var finalObserver = &#123; next: x =&gt; console.log('got value ' + x), error: err =&gt; console.error('something wrong occurred: ' + err), complete: () =&gt; console.log('done'),&#125;;console.log('just before subscribe');observable.subscribe(finalObserver);console.log('just after subscribe');proxyObserver在 observeOn(Rx.Scheduler.async)被创建，它的next通知函数大约如下:var proxyObserver = &#123; next: (val) =&gt; &#123; Rx.Scheduler.async.schedule( (x) =&gt; finalObserver.next(x), 0 /* delay */, val /* will be the x for the function above */ ); &#125;, // ...&#125; Async调度操作符和setTimeout或setInterval一起起作用，虽然延期可能是0。通常情况下，在js中，setTimeout(fn, 0)被当作使fn在下一个时间循环迭代中最早执行。这就解释了为什么got value 1在just after subscribe之后执行。 scheduler Types Scheduler Purpose null 通过不传递任何调度程序，通知被同步和递归地传递。 用于恒定时操作或尾递归操作。 Rx.Scheduler.queue Schedules on a queue in the current event frame (trampoline scheduler). Use this for iteration operations. Rx.Scheduler.asap Schedules on the micro task queue, which uses the fastest transport mechanism available, either Node.js’ process.nextTick() or Web Worker MessageChannel or setTimeout or others. Use this for asynchronous conversions. Rx.Scheduler.async Schedules work with setInterval. Use this for time-based operations. 翻译不全","tags":[{"name":"RXJS","slug":"RXJS","permalink":"http://littlehorsex.com/tags/RXJS/"}]},{"title":"RXJS----Operators操作符","date":"2017-03-24T13:24:45.000Z","path":"2017/03/24/RXJS-Operators操作符/","text":"RxJS如此强大的原因正是源自于它的操作符，即便可观察对象扮演着根基的角色。 操作符使得复杂的异步代码轻松的以声明的方式容易地组成。 什么是操作符？操作符是可观察对象上定义的方法，例如.map(…),.filter(…),.merge(…)，等等。当他们被调用，并不会去改变当前存在的可观察对象实例。相反，他们返回一个新的可观察对象，而且新返回的subscription订阅对象逻辑上基于调用他们的观察对象。 每一个操作符都是基于当前可观察对象创建一个新的可观察对象的函数。这是一个单纯无害的操作:之前的可观察对象仍然保持不变。 一个操作符本质上是一个将某个可观察对象作为输入然后输出另一个可观察对象的纯函数。对输出的新的可观察对象进行订阅的同时也会订阅作为输入的那个可观察对象。下面的例子，我们创建一个自定义的运算符函数，将从作为输入的可观察对象的每个值乘以10. 12345678910111213function multiplyByTen(input) &#123; var output =Rx.Observable.create(function(observer)&#123; input.subscribe(&#123; next: (v) =&gt; observer.next(10*v), error: (err) =&gt; observer.error(err), complete: () =&gt; observer.complete() &#125;); &#125;); return output;&#125;var input = Rx.Observable.from([1,2,3,4]);var output = multiplyByTen(input);output.subscribe(x=&gt;console.log(x)); 输出如下: 123410203040 注意一下我们对output的订阅导致了作为输入的可观察对象也被订阅了。我们称这种现象为”操作符的订阅链”。 实例操作符(instance operator)VS静态操作符(static operator)什么是实例操作符？通常，当引用运算符，我们假设是来自可观察对象实例的运算符。作为示例，如果multiplyByTen一个官方库中的操作符，那它大概是下面的样子: 12345678910Rx.Observable.prototype.multiplyByTen = function()&#123; var input=this; return Rx.Observable.create(function subscribe(observer)&#123; input.subscribe(&#123; next: (v) =&gt; observer.next(10*v), error: (err) =&gt; observer.error(err), complete: () =&gt; observer.complete() &#125;); &#125;);&#125; 译者注:考虑到可能会有些刚接触的人不太理解。上面的代码是这样的，操作符定义在可观察对象的原型对象上，如果某个可观察对象调用这个方法，input首先取得作为输入的该可观察对象的引用(后面会在闭包里用到)，然后该方法返回一个由create方法创建的可观察对象，也就是作为输出的可观察对象。而input.subscribe({…})是对input进行订阅。 实例操作符是使用this关键词来推演出”输入可观察对象”是神马东东 注意input并不是作为函数的参数，而是作为this所指代的那个对象。下面是我们如何使用这个操作符: 12var observable = Rx.Observable.from([1,2,3,4]).multiplyByTen();observable.subscribe(x =&gt; console.log(x)); 什么是静态操作符？不同于实力操作符，静态操作符是直接定义在类上的。一个静态操作符并不在其内部使用this，而是完全依赖于它的参数。 静态操作符是定义在类上的函数，通常被用于从头重新创建一个可观察对象。 最常规的静态操作符是被称作构造操作符(Creation Operators，原谅我如此翻译，总是隐隐觉得很合适~)。不同于将一个输入的可观察对象转换成一个输出的可观察对象，它们仅接收一个非可观察对象作为参数，比如一个数字，然后构造出一个可观察对象。一个静态操作符的典型例子是interval函数。它接收一个数字(而不是一个可观察对象)作为输入的参数，然后到一个可观察对象作为输出。 1var observable = Rx.Observable.intervable(1000)//1000毫秒 另一个构造操作符是create,我们在之前的例子中曾大量使用，一些合并操作符可能是静态的，例如:merge,combineLatest,concat,等等。将这些操作符声明为静态的是有意义的，因为他们接收多个可观察对象作为参数，而不是一个，示例如下: 123var observable1 = Rx.Observable.interval(1000);var observable2 = Rx.Observable.interval(400);var merged = Rx.Observable.merge(observable1, observable2); Marble diagrams弹珠图标使用文字来形容操作符到底是怎样得工作模式终究还是有那么点力不从心。许多的操作符是和时间线密不可分的，在实际中他们可能需要对值进行延迟、采样、节流、或者抖动的发射。使用图表通常能够对他们的过程进行更好的表述。弹珠图标能够囊括作为输入的可观察对象、操作符、及其参数、作为输出的可观察对象来对操作符的工作方式进行生动的表示。 在一个弹珠图标中，时间流向右侧，操作符描述了值(弹珠)在可观察对象执行时被怎样的发射。下图你可以看到对整个弹珠图表流程的分析。 [] 贯穿此后的文档，我们将会广泛的使用大理石图标来解释操作的工作过程。他们在其它的内容的表述上也是如此的的有用,例如在一个白板或者我们的单元测试中。 Creation Operators 描述 ajax bindCallback public static bindCallback(func: function, selector: function, scheduler: Scheduler) 将一个回调函数API转化为一个能返回一个Observable的函数 bindNodeCallback create defer empty 创建一个不发射任何值的Observable,它只会发射一个complate通知。 from public static from(ish: ObservableInput, scheduler: Scheduler): Observable ObservableInput A subscribable object, a Promise, an Observable-like, an Array, an iterable or an array-like object to be converted. eg: Rx.Observable.from([1,2,3]); fromEvent Rx.Observable.fromEvent(element, eventName, [selector]) 将一个元素上的事件转化为一个Observable eg: var clicks = Rx.Observable.fromEvent(document, ‘click’); fromEventPattern fromPromise generate interval public static interval(period: number, scheduler: Scheduler): Observable interval返回一个Observable，它发出一个递增的无限整数序列。 never 创建一个不发射任何值的Observable，它可以用于测试或与其他Observable组合。 of 创建一个Observable，发射指定参数的值，一个接一个，最后发出complate。 repeat repeatWhen range public static range(start:number,count:number,scheduler:Scheduler):Observable range按顺序发出一系列连续整数，参数分别为起点和长度(注意不是终点)。 throw public static throw(error:any,scheduler:Scheduler):Observable 创建一个只发出error通知的Observable。 timer public static timer(initialDelay:number or Date,period:number,schedulaer):Observable 类似于interval,但是第一个参数用来设置发射第一个值得延迟时间 Transformation Operators 描述 buffer bufferCount bufferTime bufferToggle bufferWhen concatMap concatMapTo exhaustMap expand groupBy map mapTo mergeMap mergeMapTo mergeScan pairwise partition pluck scan switchMap switchMapTo window windowCount windowTime windowToggle windowWhen Filtering Operators 描述 debounce debounceTime distinct distinctKey distinctUntilChanged distinctUntilKeyChanged elementAt filter first ignoreElements audit auditTime last sample sampleTime single skip skipUntil skipWhile take takeLast takeUntil takeWhile throttle throttleTime Combination Operators 描述 combineAll combineLatest concat concatAll exhaust forkJoin merge mergeAll race startWith switch withLatestFrom zip zipAll Multicasting Operators 描述 cache multicast publish publishBehavior publishLast publishReplay share Error Handling Operators 描述 catch retry retryWhen Utility Operators 描述 do delay delayWhen dematerialize finally let materialize observeOn subscribeOn timeInterval timestamp timeout timeoutWith toArray toPromise Conditional and Boolean Operators 描述 defaultIfEmpty every find findIndex isEmpty Mathematical and Aggregate Operators 描述 count max min reduce","tags":[{"name":"RXJS","slug":"RXJS","permalink":"http://littlehorsex.com/tags/RXJS/"}]},{"title":"RXJS----Subject主题","date":"2017-03-24T13:04:17.000Z","path":"2017/03/24/RXJS-Subject主题/","text":"什么是Subject？ 在RxJS中，Subject是一类特殊的Observable，它可以向多个Observer多路推送数值。普通的Observable并不具备多路推送的能力（每一个Observer都有自己独立的执行环境），而Subject可以共享一个执行环境。 Subject是一种可以多路推送的可观察对象。与EventEmitter类似，Subject维护着自己的Observer。 每一个Subject都是一个Observable（可观察对象） 对于一个Subject，你可以订阅（subscribe）它，Observer会和往常一样接收到数据。从Observer的视角看，它并不能区分自己的执行环境是普通Observable的单路推送还是基于Subject的多路推送。 Subject的内部实现中，并不会在被订阅（subscribe）后创建新的执行环境。它仅仅会把新的Observer注册在由它本身维护的Observer列表中，这和其他语言、库中的addListener机制类似。 每一个Subject也可以作为Observer（观察者） Subject同样也是一个由next(v)，error(e)，和 complete()这些方法组成的对象。调用next(theValue)方法后，Subject会向所有已经在其上注册的Observer多路推送theValue。 下面的例子中，我们在Subject上注册了两个Observer，并且多路推送了一些数值： 1234567891011var subject = new Rx.Subject();subject.subscribe(&#123; next: (v) =&gt; console.log('observerA: ' + v)&#125;);subject.subscribe(&#123; next: (v) =&gt; console.log('observerB: ' + v)&#125;);subject.next(1);subject.next(2); 控制台输出结果如下： 1234observerA: 1observerB: 1observerA: 2observerB: 2 既然Subject是一个Observer，你可以把它作为subscribe（订阅）普通Observable时的参数，如下面例子所示： 123456789101112var subject = new Rx.Subject();subject.subscribe(&#123; next: (v) =&gt; console.log('observerA: ' + v)&#125;);subject.subscribe(&#123; next: (v) =&gt; console.log('observerB: ' + v)&#125;);var observable = Rx.Observable.from([1, 2, 3]);observable.subscribe(subject); // 你可以传递Subject来订阅observable 执行后结果如下： 123456observerA: 1observerB: 1observerA: 2observerB: 2observerA: 3observerB: 3 通过上面的实现：我们发现可以通过Subject将普通的Observable单路推送转换为多路推送。这说明了Subject的作用——作为单路Observable转变为多路Observable的桥梁。 还有几种特殊的Subject 类型，分别是BehaviorSubject，ReplaySubject，和 AsyncSubject。 多路推送的Observable在以后的语境中，每当提到“多路推送的Observable”，我们特指通过Subject构建的Observable执行环境。否则“普通的Observable”只是一个不会共享执行环境并且被订阅后才生效的一系列值。 通过使用Subject可以创建拥有相同执行环境的多路的Observable。 下面展示了多路的运作方式：Subject从普通的Observable订阅了数据，然后其他Observer又订阅了这个Subject，示例如下： 1234567891011121314var source = Rx.Observable.from([1, 2, 3]);var subject = new Rx.Subject();var multicasted = source.multicast(subject);// 通过`subject.subscribe(&#123;...&#125;)`订阅Subject的Observer：multicasted.subscribe(&#123; next: (v) =&gt; console.log('observerA: ' + v)&#125;);multicasted.subscribe(&#123; next: (v) =&gt; console.log('observerB: ' + v)&#125;);// 让Subject从数据源订阅开始生效：multicasted.connect(); multicast方法返回一个类似于Observable的可观察对象，但是在其被订阅后，它会表现Subject的特性。 multicast 返回的对象同时是ConnectableObservable类型的，拥有connect() 方法。 connect()方法非常的重要，它决定Observable何时开始执行。由于调用connect()后，Observable开始执行，因此，connect()会返回一个Subscription供调用者来终止执行。 引用计数通过手动调用connect()返回的Subscription控制执行十分繁杂。通常，我们希望在有第一个Observer订阅Subject后自动connnect，当所有Observer都取消订阅后终止这个Subject。 我们来分析一下下面例子中subscription的过程： 1.第一个Observer 订阅了多路推送的 Observable2.多路Observable被连接3.向第一个Observer发送 值为0的next通知4.第二个Observer订阅了多路推送的 Observable5.向第一个Observer发送 值为1的next通知6.向第二个Observer发送 值为1的next通知7.第一个Observer取消了对多路推送的Observable的订阅8.向第二个Observer发送 值为2的next通知9.第二个Observer取消了对多路推送的Observable的订阅10.取消对多路推送的Observable的连接 通过显式地调用connect()，代码如下： 123456789101112131415161718192021222324var source = Rx.Observable.interval(500);var subject = new Rx.Subject();var multicasted = source.multicast(subject);var subscription1, subscription2, subscriptionConnect;subscription1 = multicasted.subscribe(&#123; next: (v) =&gt; console.log('observerA: ' + v)&#125;);subscriptionConnect = multicasted.connect();setTimeout(() =&gt; &#123; subscription2 = multicasted.subscribe(&#123; next: (v) =&gt; console.log('observerB: ' + v) &#125;);&#125;, 600);setTimeout(() =&gt; &#123; subscription1.unsubscribe();&#125;, 1200);setTimeout(() =&gt; &#123; subscription2.unsubscribe(); subscriptionConnect.unsubscribe(); &#125;, 2000); 如果你不想显式地调用connect()方法，可以在ConnectableObservable类型的Observable上调用refCount()方法。方法会进行引用计数：记录Observable被订阅的行为。当订阅数从 0 到 1时refCount() 会调用connect() 方法。到订阅数从1 到 0，他会终止整个执行过程。 refCount 使得多路推送的Observable在被订阅后自动执行，在所有观察者取消订阅后，停止执行。 下面是示例： 1234567891011121314151617181920212223242526var source = Rx.Observable.interval(500);var subject = new Rx.Subject();var refCounted = source.multicast(subject).refCount();var subscription1, subscription2, subscriptionConnect;console.log('observerA subscribed');subscription1 = refCounted.subscribe(&#123; next: (v) =&gt; console.log('observerA: ' + v)&#125;);setTimeout(() =&gt; &#123; console.log('observerB subscribed'); subscription2 = refCounted.subscribe(&#123; next: (v) =&gt; console.log('observerB: ' + v) &#125;);&#125;, 600);setTimeout(() =&gt; &#123; console.log('observerA unsubscribed'); subscription1.unsubscribe();&#125;, 1200);setTimeout(() =&gt; &#123; console.log('observerB unsubscribed'); subscription2.unsubscribe();&#125;, 2000); 执行输出结果如下: 12345678observerA subscribedobserverA: 0observerB subscribedobserverA: 1observerB: 1observerA unsubscribedobserverB: 2observerB unsubscribed 只有ConnectableObservables拥有refCount()方法，调用后会返回一个Observable而不是新的ConnectableObservable。 BehaviorSubjectBehaviorSubject是Subject的一个衍生类，具有“最新的值”的概念。它总是保存最近向数据消费者发送的值，当一个Observer订阅后，它会即刻从BehaviorSubject收到“最新的值”。 BehaviorSubjects非常适于表示“随时间推移的值”。举一个形象的例子，Subject表示一个人的生日，而Behavior则表示一个人的岁数。（生日只是一天，一个人的岁数会保持到下一次生日之前。） 下面例子中，展示了如何用 0初始化BehaviorSubject，当Observer订阅它时，0是第一个被推送的值。紧接着，在第二个Observer订阅BehaviorSubject之前，它推送了2，虽然订阅在推送2之后，但是第二个Observer仍然能接受到2： 1234567891011121314var subject = new Rx.BehaviorSubject(0 /* 初始值 */);subject.subscribe(&#123; next: (v) =&gt; console.log('observerA: ' + v)&#125;);subject.next(1);subject.next(2);subject.subscribe(&#123; next: (v) =&gt; console.log('observerB: ' + v)&#125;);subject.next(3); 输出结果如下： 123456observerA: 0observerA: 1observerA: 2observerB: 2observerA: 3observerB: 3 ReplaySubjectReplaySubject 如同于BehaviorSubject是 Subject 的子类。通过 ReplaySubject可以向新的订阅者推送旧数值，就像一个录像机ReplaySubject可以记录Observable的一部分状态（过去时间内推送的值）。 .一个ReplaySubject可以记录Observable执行过程中推送的多个值，并向新的订阅者回放它们。 你可以指定回放值的数量： 12345678910111213141516var subject = new Rx.ReplaySubject(3 /* 回放数量 */);subject.subscribe(&#123; next: (v) =&gt; console.log('observerA: ' + v)&#125;);subject.next(1);subject.next(2);subject.next(3);subject.next(4);subject.subscribe(&#123; next: (v) =&gt; console.log('observerB: ' + v)&#125;);subject.next(5); 输出如下： 123456789observerA: 1observerA: 2observerA: 3observerA: 4observerB: 2observerB: 3observerB: 4observerA: 5observerB: 5 除了回放数量，你也可以以毫秒为单位去指定“窗口时间”，决定ReplaySubject记录多久以前Observable推送的数值。下面的例子中，我们把回放数量设置为100，把窗口时间设置为500毫秒： 1234567891011121314var subject = new Rx.ReplaySubject(100, 500 /* windowTime */);subject.subscribe(&#123; next: (v) =&gt; console.log('observerA: ' + v)&#125;);var i = 1;setInterval(() =&gt; subject.next(i++), 200);setTimeout(() =&gt; &#123; subject.subscribe(&#123; next: (v) =&gt; console.log('observerB: ' + v) &#125;);&#125;, 1000); 第二个Observer接受到3（600ms）, 4（800ms） 和 5（1000ms），这些值均在订阅之前的500毫秒内推送（窗口长度 1000ms - 600ms = 400ms &lt; 500ms）： 12345678910observerA: 1observerA: 2observerA: 3observerA: 4observerA: 5observerB: 3observerB: 4observerB: 5observerA: 6observerB: 6 AsyncSubjectAsyncSubject是Subject的另外一个衍生类，Observable仅会在执行完成后，推送执行环境中的最后一个值。 1234567891011121314151617var subject = new Rx.AsyncSubject();subject.subscribe(&#123; next: (v) =&gt; console.log('observerA: ' + v)&#125;);subject.next(1);subject.next(2);subject.next(3);subject.next(4);subject.subscribe(&#123; next: (v) =&gt; console.log('observerB: ' + v)&#125;);subject.next(5);subject.complete(); 输出结果如下： 12observerA: 5observerB: 5 AsyncSubject 与 last() 操作符相似，等待完成通知后推送执行过程的最后一个值。","tags":[{"name":"RXJS","slug":"RXJS","permalink":"http://littlehorsex.com/tags/RXJS/"}]},{"title":"RXJS----Subscription订阅","date":"2017-03-24T12:34:41.000Z","path":"2017/03/24/RXJS-Subscription订阅/","text":"什么是订阅？订阅是一个表示一次性资源的对象，通常是一个可观察对象的执行。订阅对象有一个重要的方法:unsubscribe，该方法不需要参数，仅仅去废弃掉可观察对象所持有的资源。在以往的RxJS的版本中，”Subscription订阅”被称为”Disposable”。 123456var observable = Rx.Observable.interval(1000);var subscription = observable.subscribe(x =&gt; console.log(x));// Later:// This cancels the ongoing Observable execution which// was started by calling subscribe with an Observer.subscription.unsubscribe(); 订阅对象有一个unsubscribe()方法用来释放资源或者取消可观察对象的执行。 订阅对象也可以被放置在一起，因此对一个订阅对象的unsubscribe()进行调用，可以对多个订阅进行取消。做法是:把一个订阅”加”进另一个订阅。 123456789101112var observable1 = Rx.Observable.interval(400);var observable2 = Rx.Observable.interval(300);var subscription = observable1.subscribe(x =&gt; console.log('first: ' + x));var childSubscription = observable2.subscribe(x =&gt; console.log('second: ' + x));subscription.add(childSubscription);setTimeout(() =&gt; &#123;// Unsubscribes BOTH subscription and childSubscriptionsubscription.unsubscribe();&#125;, 1000); 执行之后，我们可以在控制台得到: 12345second: 0first: 0second: 1first: 1second: 2 订阅也有一个remove(otherSubscription)方法,用于解除被add添加的子订阅。","tags":[{"name":"RXJS","slug":"RXJS","permalink":"http://littlehorsex.com/tags/RXJS/"}]},{"title":"RXJS----observer观察者","date":"2017-03-24T12:28:20.000Z","path":"2017/03/24/RXJS-observer观察者/","text":"什么是观察者？观察者是可观察对象所发送数据的消费者，观察者简单而言是一组回调函数 ， 分别对应一种被可观察对象发送的通知的类型:next, error和complete。下面是一个典型的观察者对象的例子: 12345var observer=&#123; next:x=&gt;console.log('Observer got a next value: ' + x), error: err =&gt; console.error('Observer got an error: ' + err), complete: () =&gt; console.log('Observer got a complete notification')&#125; 去使用观察者，需要订阅可观察对象: 1observable.subscribe(observer) 观察者不过是三个回调函数组成的对象，每个回调函数分别对应可观察对象的通知类型。 RxJS中的观察者是可选的，如果你不提供某个回调函数，可观察对象的执行仍然会照常发生，当然某个类型的通知将不会发生，因为在观察者对象中没有对应于他们的回调函数。 下面的例子中是一个没有complete回调的观察者对象: 1234var observer=&#123; next: x=&gt;console.log('Observer got a next value: ' + x), error: err =&gt; console.error('Observer got an error: ' + err),&#125; 当订阅一个可观察对象，你可能仅仅提供回调来作为参数就够了，并不需要完整的观察者对象，作为示例: 1234567observable.subscribe(x =&gt; console.log('Observer got a next value: ' + x));在observable.subscribe内部，它将使用第一个回调参数作为next的处理句柄创建一个观察者对象。也可以通过将三个函数作为参数提供三种回调:observable.subscribe( x =&gt; console.log('Observer got a next value: ' + x), err =&gt; console.error('Observer got an error: ' + err), () =&gt; console.log('Observer got a complete notification'));","tags":[{"name":"RXJS","slug":"RXJS","permalink":"http://littlehorsex.com/tags/RXJS/"}]},{"title":"RXJS----observable可观察对象","date":"2017-03-24T08:19:25.000Z","path":"2017/03/24/RXJS-observable可观察对象/","text":"observable可观察对象 可观察对象以惰性的方式推送多值的集合。 Single单值 Multiple多值 pull拉 Function Iterator push推 Promise Observable 下面的例子是一个推送1,2，3,4数值的可观察对象，一旦它被订阅1,2，3,就会被推送，4则会在订阅发生一秒之后被推送，紧接着完成推送。 123456789var observable = Rx.Observable.create(function (observer) &#123; observer.next(1); observer.next(2); observer.next(3); setTimeout(() =&gt; &#123; observer.next(4); observer.complete(); &#125;, 1000);&#125;); 调用可观察对象然后得到它所推送的值，我们订阅它，如下 1234567console.log('just before subscribe');observable.subscribe(&#123; next: x =&gt; console.log('got value ' + x), error: err =&gt; console.error('something wrong occurred: ' + err), complete: () =&gt; console.log('done'),&#125;);console.log('just after subscribe'); 结果如下 1234567just before subscribegot value 1got value 2got value 3just after subscribegot value 4done Pull拉取 VS Push推送拉和推是数据生产者和数据的消费者两种不同的交流协议(方式) 什么是”Pull拉”？在”拉”体系中，数据的消费者决定何时从数据生产者那里获取数据，而生产者自身并不会意识到什么时候数据将会被发送给消费者。每一个JS函数都是一个“拉”体系，函数是数据的生产者，调用函数的代码通过“拉出”一个单一的返回值来消费该数据(return 语句)。ES6介绍了iterator迭代器和Generator生成器——另一中“拉”体系，调用iterator.next()的代码是消费者，可从中拉取多个值。 producer Consumer pull拉 Passive(被动的一方):被请求的时候产生数据 Active(起主导的一方):决定何时请求数据 push推 Active:按自己的节奏生产数据 Passive:对接收的数据做出反应(处理接收到的数据) 什么是”Push推”？在推体系中，数据的生产者决定何时发送数据给消费者，消费者不会在接收数据之前意识到它将要接收这个数据。Promise(承诺))是当今JS中最常见的Push推体系，一个Promise(数据的生产者)发送一个resolved value(成功状态的值)来注册一个回调(数据消费者)，但是不同于函数的地方的是：Promise决定着何时数据才被推送至这个回调函数。RxJS引入了Observables(可观察对象)，一个全新的”推体系”。一个可观察对象是一个产生多值的生产者，并”推送给”Observer(观察者)。 Function:只在调用时惰性的计算后同步地返回一个值 Generator(生成器):惰性计算，在迭代时同步的返回零到无限个值(如果有可能的话) Promise是一个可能(也可能不)返回一个单值的计算。 Observable是一个从它被调用开始，可异步或者同步的返回零到多个值的惰性执行运算。 可观察对象——作为更一般化的函数与常见的主张相悖的是，可观察对象不像EventEmitters(事件驱动)，也不象Promises因为它可以返回多个值。可观察对象可能会在某些情况下有点像EventEmitters(事件驱动)，也即是当它们使用Subjects被多播时，但是大多数情况下，并不像EventEmitters. 可观察对象像一个零参的函数，但是允许返回多个值使得其更加的一般化。 思考下面的程序 123456789function foo() &#123; console.log('Hello'); return 42;&#125;var x = foo.call(); // same as foo()console.log(x);var y = foo.call(); // same as foo()console.log(y); 我们可以看到这样的输出。 1234\"Hello\"42\"Hello\"42 使用Observables得到同样的结果 1234567891011var foo=Rx.Observable.create(function(observer)&#123; console.log('Hello'); observer.next(42);&#125;);foo.subscribe(function(x)&#123; console.log(x)；&#125;);foo.subscribe(function (y)&#123; console.log(y);&#125;); 得到同样的输出 1\"Hello\" 42 \"Hello\" 42 这种情况源自于函数和可观察对象均是惰性计算。如果你不’call(调用)’函数,console.log(‘Hello’)将不会发生。可观察对象同样如此，如果你不”调用”(使用subscribe，订阅)，console.log(‘Hello’)也将不会发生。此外，’calling’或者’subscribing’是一个独立的操作:两次函数调用触发两个独立副作用，两次订阅触发两个独立的副作用。相反的，EventEmitters:共享副作用并且不管订阅者的存在而去执行。 订阅一个可观察对象类似于调用一个函数。 一些人认为可观察对象是异步的。这并不确切，如果你用一些log语句包围在订阅程序的前后: 123console.log('before');console.log(foo.call());console.log('after'); 你可以得到如下结果 1234\"before\"\"Hello\"42\"after\" 类似的，使用可观察对象: 12345console.log('before');foo.subscribe(function (x) &#123;console.log(x);&#125;);console.log('after'); 输出如下: 1234\"before\"\"Hello\"42\"after\" 以上可以显示对foo的订阅是完全同步的，就像调用一个函数。 可观察对象u以同步或者异步的方式发送多个值。 好吧，调转方向，说一说可观察对象和函数的不同之处。可观察对象可以随时间”return”多个值。然而函数却做不到，你不能够使得如下的情况发生: 12345function foo() &#123; console.log('Hello'); return 42; return 100; // dead code. will never happen&#125; 函数仅仅可以返回一个值，然而，不要惊讶，可观察对象却可以做到这些。 123456789101112var foo = Rx.Observable.create(function (observer) &#123; console.log('Hello'); observer.next(42); observer.next(100); // \"return\" another value observer.next(200); // \"return\" yet another&#125;);console.log('before');foo.subscribe(function (x) &#123; console.log(x);&#125;);console.log('after'); 同步输出: 123456\"before\"\"Hello\"42100200\"after\" 当然，你也可以以异步的方式返回值。 123456789101112131415var foo = Rx.Observable.create(function (observer) &#123; console.log('Hello'); observer.next(42); observer.next(100); observer.next(200); setTimeout(() =&gt; &#123; observer.next(300); // happens asynchronously &#125;, 1000);&#125;);console.log('before');foo.subscribe(function (x) &#123; console.log(x);&#125;);console.log('after'); 输出 1234567\"before\"\"Hello\"42100200\"after\"300 总结: fun.call()意味着同步的给我一个值 observable.subscribe()意味着给我任意多个值，同步也好异步也罢。 剖析可观察对象使用Rx.Observable.create或者一个能产生可观察对象的操作符来创造一个可观察对象，使用一个观察者订阅它，执行然后给观察者发送next/error/complete通知。他们的执行可能会被disposed(处理)。这四个方面均被编码进可观察对象的实例中。但是其中的某些方面和其他的类型有关，如Observer和Subscription核心的可观察对象概念(个人觉得这一块还是不翻译的好，原汁原味) Creating Observables Subscribing to Observables Executing the Observable Disposing Observables Creating Observables Creating ObservablesRx.Observable.create 是可观察对象构造函数的别名，它接受一个参数:the subscribe function。下面的例子创造一每秒向观察者发射一个字符串”hi”的可观察对象。 12345var observable = Rx.Observable.create(function subscribe(observer) &#123;var id = setInterval(() =&gt; &#123;observer.next('hi')&#125;, 1000);&#125;); 可观察对象可以使用create创建，但是通常我们使用被称为creation operators,像of,from,interval等。 在上面的例子中，subscribe(订阅)函数是订阅可观察对象最重要的部分。接下来让我们看下订阅的含义是什么。 订阅可观察对象观察对象可以像下面的例子那样被订阅: 1observable.subscribe(x =&gt; console.log(x)); observable.subscribe和Observable.create(function subscribe(observer){})的subcribe回调函数有着同样的名字并不是因缘巧合。在RxJS中，他们是不同的，但是为了更实用的目的，你可以认为他们在概念上是等价的。这显示出对于同一个可观察对象进行订阅的多个观察者之间的回调函数是不共享信息的。当使用observer调用observable.subscribe时，Observable.create(function subscribe(observer){})中的subscribe函数为既定的observer运行。每次调用observable.subscribe为给定的观察者触发它自身独立的设定程序。 订阅一个可观察对象就像调用一个函数，在数据将被发送的地方提供回调。 完全不同于诸如addEventListener/removeEventListener事件句柄API.使用observable.subscribe,给定的观察者并没有作为一个监听者被注册。可观察对象甚至也不保存有哪些观察者。订阅是启动可观察对象执行和发送值或者事件给观察者的简单方式。 执行可观察对象在Observable.create(function(observer){…})中的代码，表示了一个可观察对象的执行，一个仅在观察者订阅的时候发生的惰性计算。执行随着时间产生多个值，以同步或者异步的方式。下面是可观察对象执行可以发送的三种类型的值 “Next”: 发送一个数字/字符串/对象等值。 “Error”: 发送一个JS错误或者异常。 “Complete” 不发送值。 Next通知是最重要且最常见的类型:它们代表发送给观察者的确切数据，Error和Complete通知可能仅在可观察对象执行期间仅发生一次，但仅会执行二者之中的一个。这些约束条件能够在可观察对象语法以类似于正则表达式的方式表达的更清晰: 1next*(error|complete)? 一个可观察对象的执行期间，零个到无穷多个next通知被发送。如果Error或者Complete通知一旦被发送，此后将不再发送任何值。 下面这个例子，可观察对象执行然后发送三个next通知，然后completes: 123456var observable = Rx.Observable.create(function subscribe(observer) &#123; observer.next(1); observer.next(2); observer.next(3); observer.complete();&#125;); 可观察对象严格的坚守这个契约，所以，下面的代码将不会发送包含数值4的next通知 1234567var observable = Rx.Observable.create(function subscribe(observer) &#123; observer.next(1); observer.next(2); observer.next(3); observer.complete(); observer.next(4); // Is not delivered because it would violate the contract&#125;); 不失为一个好方式的是，使用try/catch语句包裹通知语句，如果捕获了异常将会发送一个错误通知。 12345678910var observable = Rx.Observable.create(function subscribe(observer) &#123; try &#123; observer.next(1); observer.next(2); observer.next(3); observer.complete(); &#125; catch (err) &#123; observer.error(err); // delivers an error if it caught one &#125;&#125;); 处理可观察对象的执行由于可观察对象的执行可能是无限的(不停地next)，而对于观察者来说却往往希望在有限的时间内终止执行，因此我们需要一个API来取消执行。因为每一次的执行仅仅服务于一个观察者，一旦观察者停止接收数据，它就不得不通过一个方式去终止执行，从而避免浪费大量的计算性能和内存资源。 当observable.subscribe被调用，观察者将专注于最新被创建的可观察对象的执行，并且这个调用返回一个对象:the SUbscription 1var subscription = observable.subscribe(x =&gt; console.log(x)); the Subscription(订阅)表示正在进行的执行，这里有一个用于终止执行的小型的API。 阅读更多关于Subscription的信息。使用subscription.unsubscribe()你可以取消正在进行的执行: 1234var observable = Rx.Observable.from([10, 20, 30]);var subscription = observable.subscribe(x =&gt; console.log(x));// Later:subscription.unsubscribe(); 在你订阅了之后，你将会得到一个Subscription对象，它表示正在进行的执行。大胆的去使用unsubscribe()去终止执行吧。 当我们使用create()创建可观察对象，每一个可观察对象必须确定怎样去处理该执行的资源。你可以通过在subscribe函数内返回的subscription调用unsubscribe函数做到这一点。作为示例，下面是怎样去清除一个serInterval间隔执行 1234567891011var observable = Rx.Observable.create(function subscribe(observer) &#123; // Keep track of the interval resource var intervalID = setInterval(() =&gt; &#123; observer.next('hi'); &#125;, 1000); // Provide a way of canceling and disposing the interval resource return function unsubscribe() &#123; clearInterval(intervalID); &#125;;&#125;); 就像observable.subscribe类似于Observable.create(function subscribe(){…}),我们从subscribe函数中返回的unsubscribe函数在概念上等价于subscription.unsubscription。事实上，如果我们移除环绕于这些概念之外的ReactiveX类型，也就只剩下更加直观的JavaScript。 1234567891011121314function subscribe(observer) &#123; var intervalID = setInterval(() =&gt; &#123; observer.next('hi'); &#125;, 1000); return function unsubscribe() &#123; clearInterval(intervalID); &#125;;&#125;var unsubscribe = subscribe(&#123;next: (x) =&gt; console.log(x)&#125;);// Later:unsubscribe(); // dispose the resources 我们使用诸如可观察对象，观察者，和订阅等Rx类型的原因是能够兼顾安全性(例如Observable,Observer,Subscription)和操作符的的可组合性。","tags":[{"name":"RXJS","slug":"RXJS","permalink":"http://littlehorsex.com/tags/RXJS/"}]},{"title":"RXJS----Introduce","date":"2017-03-24T07:35:07.000Z","path":"2017/03/24/RXJS-Introduce/","text":"RxJS是一个通过使用可观察序列来构建异步和基于事件的程序的库。它提供了一个核心类型:Observable、卫星类型(大概是这些类型均围绕于Observable，也就是Observable是根基，而这些是辅助类型):Observer、Schedulers、Subjects)和操作符-衍生自一些数组方法，使得我们可以把异步事件以集合的方式进行处理。 把RxJS当做一个针对事件的Lodash(一个JS库)。 ReactiveX将观察者模式与迭代器模式和使用集合的函数式编程组合在一起，来满足这种管理事件序列的理想方式 RxJS中解决异步事件管理的基本概念如下： Observable可观察对象：表示一个可调用的未来值或者事件的集合。 Observer观察者：一个回调函数集合,它知道怎样去监听被Observable发送的值 Subscription订阅： 表示一个可观察对象的执行，主要用于取消执行。 Operators操作符： 纯粹的函数，使得以函数编程的方式处理集合比如:map,filter,contact,flatmap。 Subject(主题)：等同于一个事件驱动器，是将一个值或者事件广播到多个观察者的唯一途径。 Schedulers(调度者)： 用来控制并发，当计算发生的时候允许我们协调，比如setTimeout,requestAnimationFrame。 第一个例子通常你这样注册事件监听： 12var button = document.querySelector('button');button.addEventListener('click', () =&gt; console.log('Clicked!')); 使用RxJS创建一个可观察对象： 123var button = document.querySelector('button');Rx.Observable.fromEvent(button, 'click') .subscribe(() =&gt; console.log('Clicked!')); PurityRxJX能够使用纯函数的方式生产值的能力使得它强大无比。这意味着你的代码不再那么频繁的出现错误提示。通常情况下你会创造一个非纯粹的函数，然后你的代码的其他部分可能搞乱你的程序状态。 123var count = 0;var button = document.querySelector('button');button.addEventListener('click', () =&gt; console.log(`Clicked $&#123;++count&#125; times`)); 使用RxJS来隔离你的状态 1234var button = document.querySelector('button');Rx.Observable.fromEvent(button, 'click') .scan(count =&gt; count + 1, 0) .subscribe(count =&gt; console.log(`Clicked $&#123;count&#125; times`)); scan操作符和数组中reduce方法的类似， 它需要一个传递给回调函数的参数值。 回调函数的返回值将成为下一次回调函数运行时要传递的下一个参数值。 Flow 流RxJS有着众多的操作符，可以帮助您控制事件如何流入可观察对象observables。每秒最多只能点击一次的实现，使用纯JavaScript： 12345678910var count = 0;var rate = 1000;var lastClick = Date.now() - rate;var button = document.querySelector('button');button.addEventListener('click', () =&gt; &#123; if (Date.now() - lastClick &gt;= rate) &#123; console.log(`Clicked $&#123;++count&#125; times`); lastClick = Date.now(); &#125;&#125;); 使用RxJS 12345var button = document.querySelector('button');Rx.Observable.fromEvent(button, 'click') .throttleTime(1000) .scan(count =&gt; count + 1, 0) .subscribe(count =&gt; console.log(`Clicked $&#123;count&#125; times`)); 其他的流操作符是filter, delay, debounceTime, take, takeUntil, distinct, distinctUntilChanged 等等。 Values值你可以通过可观察对象来转化值下面的程序可以在每次点击鼠标时获取X坐标位置纯的JS实现 12345678910var count = 0;var rate = 1000;var lastClick = Date.now() - rate;var button = document.querySelector('button');button.addEventListener('click', (event) =&gt; &#123; if (Date.now() - lastClick &gt;= rate) &#123; console.log(++count + event.clientX) lastClick = Date.now(); &#125;&#125;); RxJS实现 123456var button = document.querySelector('button');Rx.Observable.fromEvent(button, 'click') .throttleTime(1000) .map(event =&gt; event.clientX) .scan((count, clientX) =&gt; count + clientX, 0) .subscribe(count =&gt; console.log(count)); 其他的值生产者还有 pluck, pairwise, sample 等等.","tags":[{"name":"RXJS","slug":"RXJS","permalink":"http://littlehorsex.com/tags/RXJS/"}]},{"title":"Javascript-算法-set map","date":"2017-03-17T07:54:37.000Z","path":"2017/03/17/Javascript-算法-set-map/","text":"set：类似于数组，但所有成员的值都是唯一的 var set = new Set([1, 3]);使用for of遍历Array.from方法可以将set结构转为数组Array.from(new Set(array))可以数组去重[…new Set(array)] 方法 描述 set.add(value) 添加某个值，返回set本身 set.delete(value) 删除某个值，返回布尔，表示是否删除成功 set.has(value) 返回boolean set.clear() 清除所有成员 set.keys() set.values() set.entries() 返回一个键值对的遍历器 set.forEach() new Set([…a, …b]) 并集 new Set([…a].filter(x =&gt; b.has(x))) 交集 new Set([…a].filter(x =&gt; !b.has(x))) 差集 map:键值对的集合var map = new Map();map.set([‘a’], 555);map.get([‘a’]);上面的set和get方法，表面上针对同一个键，但实际上这两个值内存地址不一样，会返回undefined 方法 描述 map.set(key, value) 添加某个值，返回map本身 map.get(key) 读取某个值 map.has(key) map.delete(key) 删除某个值 map.keys() map.values() map.entries() 返回一个键值对的遍历器 set.forEach()","tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://littlehorsex.com/tags/数据结构与算法/"}]},{"title":"Javascript-算法-tree","date":"2017-03-17T07:53:51.000Z","path":"2017/03/17/Javascript-算法-tree/","text":"","tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://littlehorsex.com/tags/数据结构与算法/"}]},{"title":"Javascript-算法-linked list","date":"2017-03-16T13:53:17.000Z","path":"2017/03/16/Javascript-算法-linked-list/","text":"链表：任意添加或移除项，它会按需进行扩容。 要存储多个元素，数组(或列表)可能是最常用的数据结构。这种数据结构非常方便，提供了一个便利的[]语法来访问它的元素。然而，这种数据结构有一个缺点:数组的大小是固定的，从数组的起点或中间插入 或移除项的成本很高，因为需要移动元素。 链表存储有序的元素集合，但不同于数组，链表中的元素在内存中并不是连续放置的。每个元素由一个存储元素本身的节点和一个指向下一个元素的引用组成。 方法 描述 append(element) 向列表尾部添加一个新项。 insert(position, element) 向列表的特定位置插入一个新项。 remove(element) 从列表中移除一项。 removeAt(position) 从列表的特定位置移除一项。 indexOf(element) 返回元素在列表中的索引。如果列表中没有该元素则返回-1。 isEmpty() 如果链表中不包含任何元素，返回true，否则返回false。 size() 返回链表包含的元素个数。 toString() 由于列表项使用了Node类，就需要重写继承自JavaScript对象默认的toString方法，让其只输出元素的值。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798const Node = function(element)&#123; this.element = element; this.next = null;&#125;;function LinkedList() &#123; let length = 0; let head = null; this.append = function(element)&#123; const node = new Node(element); let current; if(length == 0)&#123; head = node; &#125;else&#123; current = head; while(current.next)&#123; current = current.next; &#125; current.next = node; &#125; length ++; &#125;; this.insert = function(position, element)&#123; if(position &gt;=0 &amp;&amp; position &lt;= length)&#123; const node = new Node(element); let current = head, index = 0; if(position == 0)&#123; node.next = head; head = node; &#125;else&#123; while(index != position - 1)&#123; current = current.next; index ++; &#125; node.next = current.next; current.next = node; &#125; length ++; return true; &#125;else&#123; return false; &#125; &#125;; this.removeAt = function(position)&#123; if(position &gt; -1 &amp;&amp; position &lt; length)&#123; let removeEle = head; if(position == 0)&#123; head = head.next; &#125;else&#123; let current = head, index = 0; while(index != position - 1)&#123; current = current.next; index ++; &#125; removeEle = current.next; current.next = current.next.next; &#125; length --; return removeEle.element; &#125;else&#123; return null; &#125; &#125;; this.remove = function(element)&#123;&#125;; this.indexOf = function(element)&#123; let current = head, index = 0; while(current)&#123; if(current.element == element)&#123; return index; &#125;else&#123; current = current.next; index ++; &#125; &#125; return -1; &#125;; this.isEmpty = function() &#123; return (length == 0); &#125;; this.size = function() &#123; return length; &#125;; this.getHead = function() &#123; return head; &#125;; this.toString = function()&#123; let current = head, string = ''; while(current)&#123; string = string + current.element; current = current.next; &#125; return string; &#125;; this.print = function()&#123;&#125;;&#125;const list = new LinkedList();list.append(1);list.append(7);list.append(4);","tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://littlehorsex.com/tags/数据结构与算法/"}]},{"title":"Javascript-算法-array","date":"2017-03-16T12:11:45.000Z","path":"2017/03/16/Javascript-算法-array/","text":"普通数组 方法 描述 array.push() 尾部添加 array.pop() 尾部删除 array.shift() 头部删除 array.unshift() 头部添加 array.splice(5, 0, 1, 2) 索引值为5的地方插入1 2 array.concat 连接2个或更多数组，并返回结果 array.every 对数组中的每一项运行给定函数，如果该函数对每一项都返回true，则返回true aray.some 如果该函数对任意一项返回true，则返回true array.filter 对数组中的每一项运行给定函数，返回该函数会返回true的项组成的数组 array.forEach 对数组中的每一项运行给定函数。这个方法没有返回值 array.map 对数组中的每一项运行给定函数，返回每次函数调用的结果组成的数组 数组模拟栈（后进先出） 方法 描述 push(element(s)) 添加一个(或几个)新元素到栈顶。 pop() 移除栈顶的元素，同时返回被移除的元素。 peek() 返回栈顶的元素，不对栈做任何修改(这个方法不会移除栈顶的元素，仅仅返回它)。 isEmpty() 如果栈里没有任何元素就返回true，否则返回false。 clear() 移除栈里的所有元素。 size() 返回栈里的元素个数。这个方法和数组的length属性很类似。 数组模拟队列（先进先出） 方法 描述 enqueue(element(s)) 向队列尾部添加一个(或多个)新的项。 dequeue() 移除队列的第一项，并返回被移除的元素。 front() 返回队列中第一个元素——最先被添加，也将是最先被移除的元素。队列不做任何变动(不移除元素，只返回元素信息)。 isEmpty() 如果队列中不包含任何元素，返回true，否则返回false。 size() 返回队列包含的元素个数，与数组的length属性类似。 循环队列——击鼓传花1234567891011121314151617181920function hotPotato(nameList, num)&#123; var queue = new Queue(); for (var i=0; i&lt;nameList.length; i++)&#123; queue.enqueue(nameList[i]); // 得到一份名单，把里面的名字全都加入队列 &#125; var eliminated = ''; while (queue.size() &gt; 1)&#123; for (var i=0; i&lt;num; i++)&#123; queue.enqueue(queue.dequeue()); // 给定一个数字，然后迭代队列。从队列开头移除一项，再将其添加到队列末尾 &#125; eliminated = queue.dequeue(); // 一旦传递次数达到给定的数字，拿着花的那个人就被淘汰了 console.log(eliminated + '在击鼓传花游戏中被淘汰。'); &#125; return queue.dequeue(); &#125; var names = ['John','Jack','Camila','Ingrid','Carl']; var winner = hotPotato(names, 7); console.log('胜利者:' + winner);","tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://littlehorsex.com/tags/数据结构与算法/"}]},{"title":"JavaScript 运行机制---q","date":"2017-03-04T06:05:27.000Z","path":"2017/03/04/JavaScript-运行机制-q/","text":"123for (var i = 0; i &lt; 5; i++) &#123; console.log(i);&#125; // 0 1 2 3 4 12345for (var i = 0; i &lt; 5; i++) &#123; setTimeout(function() &#123; console.log(i); &#125;, 1000 * i);&#125; // 5 5 5 5 5 开始输出一个 5，然后每隔一秒再输出一个 5，一共 5 个 5 1234567for (var i = 0; i &lt; 5; i++) &#123; (function(i) &#123; setTimeout(function() &#123; console.log(i); &#125;, i * 1000); &#125;)(i);&#125; // 0 1 2 3 4 闭包，内部对 i 保持引用 1234567for (var i = 0; i &lt; 5; i++) &#123; (function() &#123; setTimeout(function() &#123; console.log(i); &#125;, i * 1000); &#125;)(i);&#125; // 5 5 5 5 5 内部没有对i引用 12345for (var i = 0; i &lt; 5; i++) &#123; setTimeout((function(i) &#123; console.log(i); &#125;)(i), i * 1000);&#125; // 0 1 2 3 4 立即执行函数 12345678910111213setTimeout(function() &#123; console.log(1)&#125;, 0);new Promise(function executor(resolve) &#123; console.log(2); for( var i=0 ; i&lt;10000 ; i++ ) &#123; i == 9999 &amp;&amp; resolve(); &#125; console.log(3);&#125;).then(function() &#123; console.log(4);&#125;);console.log(5); 这道题应该考察 JavaScript 的运行机制的，让我理一下思路。首先先碰到一个 setTimeout，于是会先设置一个定时，在定时结束后将传递这个函数放到任务队列里面，因此开始肯定不会输出 1 。然后是一个 Promise，里面的函数是直接执行的，因此应该直接输出 2 3 。然后，Promise 的 then 应当会放到当前 tick 的最后，但是还是在当前 tick 中。因此，应当先输出 5，然后再输出 4 。最后在到下一个 tick，就是 1 。“2 3 5 4 1”","tags":[{"name":"习得","slug":"习得","permalink":"http://littlehorsex.com/tags/习得/"}]},{"title":"JavaScript 运行机制---a","date":"2017-03-04T06:05:19.000Z","path":"2017/03/04/JavaScript-运行机制-a/","text":"工作做完的闲暇之余逛了segmentfault，发现了一篇有意思的文章——JavaScript 运行机制—q，发现自己对javascript的闭包以及运行机制并不了解，特查资料，整理。 123456789function f1()&#123; var n=999; // n为f1函数的内部变量，外部无法访问 function f2()&#123; // f2为f1的内部函数，可以访问f1的内部变量，只要返回f2，外部也可以访问f1的内部变量了 alert(n); &#125; return f2;&#125;var result=f1();result(); // 999 F2函数就是闭包，闭包就是能够读取其他函数内部变量的函数，是把函数内部和外部连接的桥梁。 闭包的作用有两个：一是可以读取函数内部的变量，二是让这些变量的值始终存在内存中。 123456789101112function f1()&#123; var n=999; nAdd=function()&#123;n+=1&#125; function f2()&#123; alert(n); &#125; return f2;&#125;var result=f1();result(); // 999nAdd();result(); // 1000 这段代码中，rusult实际上就是闭包函数f2，他一共运行了两次，第一次为999，第二次为1000，这证明了函数f1的局部变量n一直保存在内存中，并没有在f1调用之后被自动清除。原因是，f1是f2的父函数，而f2赋值给了一个全局变量，导致f2始终在内存中，而f2始终依赖于f1，因此f1也始终在内存中，不会在调用后被垃圾回收机制回收。 闭包的大概内容就到此为止，下面，我们来学习一下js的运行机制。 js的一大特点就是单线程，也就是同一时间只能做一件事。单线程就意味着所有任务需要排队，前一个任务结束才会进行下一个任务。当任务需要IO设备时，（比如等着ajax操作获取数据）虽然CPU是空闲状态，但不得不等着结果返回才能进行下一个任务。这时，主线程完全可以不管IO设备，挂起等待中的任务，先运行排在后面的任务，等IO设备返回了结果，再把挂起的任务继续执行。 因此，所有任务可以分为两种，一种同步任务，一种异步任务。同步任务指的是，在主线程上排队执行的任务，只有前一个任务执行结束，才能执行后一个任务。异步任务指的是，不进入主线程，而进入“任务队列”的任务，只有“任务队列”通知主线程，该任务可以执行，才进入主线程。 所有同步任务都在主线程上执行，形成一个执行栈（execution context stack）。 主线程之外，还存在一个”任务队列”（task queue）。只要异步任务有了运行结果，就在”任务队列”之中放置一个事件。 一旦”执行栈”中的所有同步任务执行完毕，系统就会读取”任务队列”，看看里面有哪些事件。那些对应的异步任务，于是结束等待状态，进入执行栈，开始执行。 主线程不断重复上面的第三步。 “任务队列”中的事件，除了IO设备的事件以外，还包括一些用户产生的事件（比如鼠标点击、页面滚动等等）。只要指定过回调函数，这些事件发生时就会进入”任务队列”，等待主线程读取。 所谓”回调函数”（callback），就是那些会被主线程挂起来的代码。异步任务必须指定回调函数，当主线程开始执行异步任务，就是执行对应的回调函数。 主线程从”任务队列”中读取事件，这个过程是循环不断的，所以整个的这种运行机制又称为Event Loop（事件循环）。 除了放置异步任务的事件，”任务队列”还可以放置定时事件，即指定某些代码在多少时间之后执行。","tags":[{"name":"习得","slug":"习得","permalink":"http://littlehorsex.com/tags/习得/"}]},{"title":"TwoDogZi之旅","date":"2017-03-03T06:50:00.000Z","path":"2017/03/03/TwoDogZi之旅/","text":"吃 已完成铁板自助潮汕牛肉火锅 待吃海鲜自助虾吃虾涮日本料理","tags":[{"name":"随笔","slug":"随笔","permalink":"http://littlehorsex.com/tags/随笔/"}]},{"title":"Hello World","date":"2017-03-03T05:57:37.000Z","path":"2017/03/03/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy 1$ hexo clean &amp;&amp; hexo g &amp;&amp; hexo d More info: Deployment","tags":[{"name":"init","slug":"init","permalink":"http://littlehorsex.com/tags/init/"}]}]